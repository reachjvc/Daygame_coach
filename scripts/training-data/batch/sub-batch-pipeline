#!/usr/bin/env bash
#
# scripts/training-data/batch/sub-batch-pipeline
#
# Stage-by-stage pipeline orchestrator for sub-batches.
# Run ONE stage at a time, review, then continue.
#
# Usage:
#   A) List all batches:
#      ./sub-batch-pipeline --list
#
#   B) Show status of a sub-batch (per-stage breakdown):
#      ./sub-batch-pipeline P001.1 --status
#
#   C) Run a single stage:
#      ./sub-batch-pipeline P001.1 --stage 06
#      ./sub-batch-pipeline P001.1 --stage 06b
#
#   D) Create symlink view for browsing:
#      ./sub-batch-pipeline P001.1 --view
#
#   E) Run validations for a sub-batch manifest:
#      ./sub-batch-pipeline P001.1 --validate
#      ./sub-batch-pipeline P001.1 --validate --validate-deep
#      ./sub-batch-pipeline P001.1 --validate --check-stage08-report --check-stage09-chunks
#      ./sub-batch-pipeline P001.1 --validate --emit-stage-reports
#      # (also validates emitted stage reports + writes readiness summary)
#
#   F) Mark sub-batch as approved:
#      ./sub-batch-pipeline P001.1 --approve
#
#   G) Show batch-level status:
#      ./sub-batch-pipeline P001 --status

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/../../.." && pwd)"
cd "$REPO_ROOT"

BATCHES_DIR="$REPO_ROOT/docs/pipeline/batches"
WAIVERS_DIR="$REPO_ROOT/docs/pipeline/waivers"
DATA_DIR="$REPO_ROOT/data"
VIEWS_DIR="$REPO_ROOT/batch-views"

# Stage definitions (all stages for view generation)
declare -A STAGE_DIRS=(
  ["01"]="01.download"
  ["02"]="02.transcribe"
  ["03"]="03.align"
  ["04"]="04.diarize"
  ["05"]="05.audio-features"
  ["06"]="06.video-type"
  ["06b"]="06b.verify"
  ["06c"]="06c.patched"
  ["07"]="07.content"
)
# Stages with nested source/video folder structure
NESTED_STAGES=("01" "02" "03" "04" "05")
# Stages that often write source-scoped flat outputs (data/<stage>/<source>/*.json) in --manifest mode
FLAT_STAGES=("06" "06b" "06c" "07")

declare -A STAGE_SCRIPTS=(
  ["06"]="$REPO_ROOT/scripts/training-data/06.video-type"
  ["06b"]="$REPO_ROOT/scripts/training-data/06b.verify"
  ["06c"]="$REPO_ROOT/scripts/training-data/06c.patch"
  ["07"]="$REPO_ROOT/scripts/training-data/07.content"
)
declare -A STAGE_PATTERNS=(
  ["01"]="*.wav"
  ["02"]="*.full.json"
  ["03"]="*.full.json"
  ["04"]="*.full.json"
  ["05"]="*.audio_features.json"
  ["06"]="*.conversations.json"
  ["06b"]="*.verification.json"
  ["06c"]="*.conversations.json"
  ["07"]="*.enriched.json"
)
# Stages that can be run via this pipeline
RUNNABLE_STAGES=("06" "06b" "06c" "07")
# All stages for view generation
ALL_STAGES=("01" "02" "03" "04" "05" "06" "06b" "06c" "07")

# Modes
MODE=""
DRY_RUN=false
STAGE=""
SUB_BATCH_ID=""
BATCH_ID=""
VALIDATE_STAGE08_REPORT=false
VALIDATE_STAGE09_CHUNKS=false
VALIDATE_WAIVER_FILE=""
VALIDATE_EMIT_STAGE_REPORTS=false
VALIDATE_STAGE_REPORTS_DIR=""

usage() {
  cat <<'EOF'
Usage:
  ./sub-batch-pipeline --list                    List all batches and sub-batches
  ./sub-batch-pipeline P001.1 --status           Per-stage status with file paths
  ./sub-batch-pipeline P001.1 --stage 06         Run stage 06 only
  ./sub-batch-pipeline P001.1 --stage 06b        Run stage 06b only
  ./sub-batch-pipeline P001.1 --view             Create symlink view in batch-views/P001/P001.1/
  ./sub-batch-pipeline P001.1 --validate         Run cross-stage validators for this sub-batch
  ./sub-batch-pipeline P001.1 --validate --validate-deep
                                                  Validate + require Stage 08 report and Stage 09 chunks checks
  ./sub-batch-pipeline P001.1 --approve          Mark as approved
  ./sub-batch-pipeline P001 --status             Batch-level status

Options:
  --dry-run                Preview without running
  --check-stage08-report   With --validate, require Stage 08 manifest report integrity
  --check-stage09-chunks   With --validate, require Stage 09 chunk payload integrity
  --validate-deep          Shortcut: --check-stage08-report + --check-stage09-chunks
  --waiver-file <path>     With --validate, apply manifest-validator waivers file
                           Default auto-detect: docs/pipeline/waivers/<subbatch>.json
  --emit-stage-reports     With --validate, emit per-video stage reports and validate contract coverage
  --stage-reports-dir <p>  Output directory for --emit-stage-reports

View structure:
  batch-views/<batch>/<subbatch>/<stage>/<source>/<video>/
  - Nested stages (01-05): symlinks to actual files
  - Flat stages (06-07): symlinks organized by source/video
  - .pending marker: stage not yet run for that video
EOF
}

error() {
  echo "ERROR: $*" >&2
  exit 1
}

# Extract batch ID from sub-batch ID (P001.1 -> P001)
get_batch_id() {
  local sub_id="$1"
  echo "${sub_id%.*}"
}

# Check if argument looks like a sub-batch (has .N suffix)
is_sub_batch() {
  [[ "$1" =~ \.[0-9]+$ ]]
}

# Extract video ID from filename/path
extract_video_id() {
  local name="$1"
  if [[ "$name" =~ \[([a-zA-Z0-9_-]{11})\] ]]; then
    echo "${BASH_REMATCH[1]}"
  fi
}

# Load manifest video IDs
load_manifest_ids() {
  local manifest="$1"
  grep -v "^#" "$manifest" | while read -r line; do
    extract_video_id "$line"
  done
}

# List all batches
list_batches() {
  echo ""
  echo "=== All Batches ==="
  echo ""

  for status_file in "$BATCHES_DIR"/*.status.json; do
    [[ -f "$status_file" ]] || continue
    python3 - "$status_file" <<'PYEOF'
import json
import sys

with open(sys.argv[1]) as f:
    data = json.load(f)

batch_id = data["batch_id"]
total = data["total_videos"]
sub_count = len(data["sub_batches"])

# Count statuses
counts = {"approved": 0, "pending_review": 0, "in_progress": 0, "not_started": 0}
for info in data["sub_batches"].values():
    counts[info["status"]] = counts.get(info["status"], 0) + 1

print(f"{batch_id}: {total} videos in {sub_count} sub-batches")
print(f"  approved: {counts['approved']}, pending: {counts['pending_review']}, in_progress: {counts['in_progress']}, not_started: {counts['not_started']}")
PYEOF
  done

  # List batches without status files (not yet split)
  for batch_file in "$BATCHES_DIR"/P*.txt; do
    [[ -f "$batch_file" ]] || continue
    batch_name=$(basename "$batch_file" .txt)
    # Skip sub-batch files (have dots)
    [[ "$batch_name" =~ \. ]] && continue
    status_file="$BATCHES_DIR/${batch_name}.status.json"
    if [[ ! -f "$status_file" ]]; then
      count=$(grep -v "^#" "$batch_file" | grep -c . || echo 0)
      echo "$batch_name: $count videos (not split yet - run sub-batch-create)"
    fi
  done
}

# Show per-stage status for a sub-batch
show_sub_batch_status() {
  local sub_id="$1"
  local batch_id
  batch_id=$(get_batch_id "$sub_id")

  local manifest="$BATCHES_DIR/${sub_id}.txt"
  if [[ ! -f "$manifest" ]]; then
    error "Sub-batch manifest not found: $manifest"
  fi

  # Get video IDs from manifest
  local -a video_ids=()
  while IFS='|' read -r source folder || [[ -n "$source" ]]; do
    [[ "$source" =~ ^# ]] && continue
    [[ -z "$source" ]] && continue
    # Trim leading/trailing whitespace without collapsing internal spaces
    source="${source#"${source%%[![:space:]]*}"}"
    source="${source%"${source##*[![:space:]]}"}"
    folder="${folder#"${folder%%[![:space:]]*}"}"
    folder="${folder%"${folder##*[![:space:]]}"}"
    vid_id=$(extract_video_id "$folder")
    [[ -n "$vid_id" ]] && video_ids+=("$vid_id:$source:$folder")
  done < "$manifest"

  local total=${#video_ids[@]}

  echo ""
  echo "=== Sub-batch $sub_id Status ($total videos) ==="
  echo ""

  for stage in "${RUNNABLE_STAGES[@]}"; do
    local stage_dir="${STAGE_DIRS[$stage]}"
    local pattern="${STAGE_PATTERNS[$stage]}"
    local found=0
    local missing=()

    for entry in "${video_ids[@]}"; do
      IFS=':' read -r vid_id source folder <<< "$entry"

      # Check if output exists for this video
      local found_file=false

      # Search in stage directory
      if [[ -d "$DATA_DIR/$stage_dir" ]]; then
        while IFS= read -r -d '' f; do
          found_file=true
          break
        # Follow symlinks when the stage dir itself is a symlink (common in worktree-based experiments).
        done < <(find -L "$DATA_DIR/$stage_dir" -name "*${vid_id}*" -name "$pattern" -print0 2>/dev/null)
      fi

      if [[ "$found_file" == true ]]; then
        ((++found))
      else
        missing+=("$folder")
      fi
    done

    local status_icon="â¬œ"
    if [[ $found -eq $total ]]; then
      status_icon="âœ…"
    elif [[ $found -gt 0 ]]; then
      status_icon="ðŸ”¶"
    fi

    printf "  %s Stage %s: %d/%d\n" "$status_icon" "$stage" "$found" "$total"

    # Show missing files if partially complete
    if [[ $found -gt 0 && $found -lt $total && ${#missing[@]} -le 5 ]]; then
      for m in "${missing[@]}"; do
        echo "      missing: $m"
      done
    elif [[ ${#missing[@]} -gt 5 ]]; then
      echo "      (${#missing[@]} missing)"
    fi
  done

  echo ""

  # Show current status from status file
  local status_file="$BATCHES_DIR/${batch_id}.status.json"
  if [[ -f "$status_file" ]]; then
    python3 - "$status_file" "$sub_id" <<'PYEOF'
import json
import sys

with open(sys.argv[1]) as f:
    data = json.load(f)

sub_id = sys.argv[2]
info = data["sub_batches"].get(sub_id, {})
status = info.get("status", "unknown")
print(f"Overall status: {status}")
PYEOF
  fi
}

# Show batch-level status (all sub-batches)
show_batch_status() {
  local batch_id="$1"
  local status_file="$BATCHES_DIR/${batch_id}.status.json"

  if [[ ! -f "$status_file" ]]; then
    error "Status file not found: $status_file (run sub-batch-create first)"
  fi

  python3 - "$status_file" <<'PYEOF'
import json
import sys

with open(sys.argv[1]) as f:
    data = json.load(f)

print(f"\nBatch {data['batch_id']} Status")
print(f"Total videos: {data['total_videos']}")
print(f"Sub-batch size: {data['sub_batch_size']}")
print()

status_symbols = {
    "approved": "\u2705",
    "pending_review": "\U0001F50D",
    "in_progress": "\u23F3",
    "not_started": "\u2B1C",
}

for sub_id in sorted(data["sub_batches"].keys(), key=lambda x: int(x.split(".")[-1])):
    info = data["sub_batches"][sub_id]
    status = info["status"]
    symbol = status_symbols.get(status, "?")
    count = info.get("video_count", "?")
    print(f"  {symbol} {sub_id}: {status} ({count} videos)")

# Summary
counts = {}
for info in data["sub_batches"].values():
    s = info["status"]
    counts[s] = counts.get(s, 0) + info.get("video_count", 0)

print()
print("Summary:")
for status in ["approved", "pending_review", "in_progress", "not_started"]:
    if status in counts:
        print(f"  {status}: {counts[status]} videos")
PYEOF
}

# Run a single stage
run_stage() {
  local sub_id="$1"
  local stage="$2"
  local batch_id
  batch_id=$(get_batch_id "$sub_id")

  local manifest="$BATCHES_DIR/${sub_id}.txt"
  if [[ ! -f "$manifest" ]]; then
    error "Sub-batch manifest not found: $manifest"
  fi

  local script="${STAGE_SCRIPTS[$stage]:-}"
  if [[ -z "$script" ]]; then
    error "Unknown stage: $stage (valid: ${RUNNABLE_STAGES[*]})"
  fi

  local stage_dir="${STAGE_DIRS[$stage]}"

  echo ""
  echo "=== Running Stage $stage for $sub_id ==="
  echo ""

  if [[ "$DRY_RUN" == true ]]; then
    echo "[DRY RUN] Would run: $script --manifest $manifest"
    return 0
  fi

  # Update status to in_progress
  local status_file="$BATCHES_DIR/${batch_id}.status.json"
  if [[ -f "$status_file" ]]; then
    python3 - "$status_file" "$sub_id" "$stage" <<'PYEOF'
import json
import sys

status_file, sub_id, stage = sys.argv[1:4]

with open(status_file) as f:
    data = json.load(f)

if sub_id in data["sub_batches"]:
    data["sub_batches"][sub_id]["status"] = "in_progress"
    data["sub_batches"][sub_id]["current_stage"] = stage

with open(status_file, "w") as f:
    json.dump(data, f, indent=2)
    f.write("\n")
PYEOF
  fi

  # Run the stage
  if "$script" --manifest "$manifest"; then
    echo ""
    echo "Stage $stage: COMPLETE"

    # Create symlink view
    create_stage_view "$sub_id" "$stage"

    return 0
  else
    echo ""
    echo "Stage $stage: FAILED (some videos may have errors)"
    return 1
  fi
}

# Check if stage is nested (has source/video folder structure)
is_nested_stage() {
  local stage="$1"
  for s in "${NESTED_STAGES[@]}"; do
    [[ "$s" == "$stage" ]] && return 0
  done
  return 1
}

# Create symlink view for a stage
create_stage_view() {
  local sub_id="$1"
  local stage="$2"
  local batch_id
  batch_id=$(get_batch_id "$sub_id")

  local stage_dir="${STAGE_DIRS[$stage]:-}"
  [[ -z "$stage_dir" ]] && return 0

  local pattern="${STAGE_PATTERNS[$stage]}"
  local manifest="$BATCHES_DIR/${sub_id}.txt"
  local view_base="$VIEWS_DIR/$batch_id/$sub_id/$stage_dir"

  # Clear existing view for this stage
  rm -rf "$view_base" 2>/dev/null || true

  local link_count=0
  local pending_count=0

  # Process each video from manifest
  while IFS='|' read -r source folder || [[ -n "$source" ]]; do
    [[ "$source" =~ ^# ]] && continue
    [[ -z "$source" ]] && continue
    # Trim leading/trailing whitespace without collapsing internal spaces
    source="${source#"${source%%[![:space:]]*}"}"
    source="${source%"${source##*[![:space:]]}"}"
    folder="${folder#"${folder%%[![:space:]]*}"}"
    folder="${folder%"${folder##*[![:space:]]}"}"
    vid_id=$(extract_video_id "$folder")
    [[ -z "$vid_id" ]] && continue

    # Create source/video folder structure in view
    local video_view_dir="$view_base/$source/$folder"
    mkdir -p "$video_view_dir"

    local found_file=false

	    if is_nested_stage "$stage"; then
	      # Nested stage: data/<stage>/<source>/<video>/
	      local src_video_dir="$DATA_DIR/$stage_dir/$source/$folder"
	      if [[ ! -d "$src_video_dir" && -d "$DATA_DIR/$stage_dir/$source" ]]; then
	        # Folder names in manifests are display-only and can drift (unicode punctuation, title edits).
	        # Resolve nested stage dirs by video_id when the exact folder is missing.
	        while IFS= read -r -d '' d; do
	          local bn
	          bn=$(basename "$d")
	          local alt_id
	          alt_id=$(extract_video_id "$bn")
	          if [[ -n "$alt_id" && "$alt_id" == "$vid_id" ]]; then
	            src_video_dir="$d"
	            break
	          fi
	        done < <(find "$DATA_DIR/$stage_dir/$source" -mindepth 1 -maxdepth 1 -type d -print0 2>/dev/null)
	      fi
	      if [[ -d "$src_video_dir" ]]; then
	        # Symlink all matching files in the video folder
	        while IFS= read -r -d '' f; do
	          found_file=true
          local link_name=$(basename "$f")
          local rel_target
          rel_target=$(realpath --relative-to="$video_view_dir" "$f")
          ln -sf "$rel_target" "$video_view_dir/$link_name" 2>/dev/null || true
          ((++link_count))
        done < <(find "$src_video_dir" -maxdepth 1 -type f -name "$pattern" -print0 2>/dev/null)
      fi
    else
      # Source-scoped flat stage (06-07 family):
      # - Preferred (future/canonical): data/<stage>/<source>/<video>/
      # - Current (manifest runs):      data/<stage>/<source>/*.json
      # - Legacy (ad-hoc runs):         data/<stage>/*.json

      # 1) Source-video layout (if present)
      local src_video_dir="$DATA_DIR/$stage_dir/$source/$folder"
      if [[ -d "$src_video_dir" ]]; then
        while IFS= read -r -d '' f; do
          found_file=true
          local link_name=$(basename "$f")
          local rel_target
          rel_target=$(realpath --relative-to="$video_view_dir" "$f")
          ln -sf "$rel_target" "$video_view_dir/$link_name" 2>/dev/null || true
          ((++link_count))
        done < <(find "$src_video_dir" -maxdepth 1 -type f -name "$pattern" -print0 2>/dev/null)
      fi

      # 2) Source-flat layout (if present)
      local src_source_dir="$DATA_DIR/$stage_dir/$source"
      if [[ "$found_file" == false && -d "$src_source_dir" ]]; then
        while IFS= read -r -d '' f; do
          found_file=true
          local link_name=$(basename "$f")
          local rel_target
          rel_target=$(realpath --relative-to="$video_view_dir" "$f")
          ln -sf "$rel_target" "$video_view_dir/$link_name" 2>/dev/null || true
          ((++link_count))
        done < <(find "$src_source_dir" -maxdepth 1 -type f -name "*${vid_id}*" -name "$pattern" -print0 2>/dev/null)
      fi

      # 3) Root-flat fallback
      if [[ "$found_file" == false && -d "$DATA_DIR/$stage_dir" ]]; then
        while IFS= read -r -d '' f; do
          found_file=true
          local link_name=$(basename "$f")
          local rel_target
          rel_target=$(realpath --relative-to="$video_view_dir" "$f")
          ln -sf "$rel_target" "$video_view_dir/$link_name" 2>/dev/null || true
          ((++link_count))
        done < <(find "$DATA_DIR/$stage_dir" -maxdepth 1 -type f -name "*${vid_id}*" -name "$pattern" -print0 2>/dev/null)
      fi
    fi

    # Create .pending marker if no files found
    if [[ "$found_file" == false ]]; then
      touch "$video_view_dir/.pending"
      ((++pending_count))
    fi
  done < "$manifest"

  echo "  $stage_dir: $link_count files, $pending_count pending"
}

# Create full symlink view for all stages
create_full_view() {
  local sub_id="$1"
  local batch_id
  batch_id=$(get_batch_id "$sub_id")

  echo ""
  echo "=== Creating View for $sub_id ==="
  echo ""

  for stage in "${ALL_STAGES[@]}"; do
    create_stage_view "$sub_id" "$stage"
  done

  echo ""
  echo "Browse: $VIEWS_DIR/$batch_id/$sub_id/"
}

# Update status
update_status() {
  local batch_id="$1"
  local sub_id="$2"
  local new_status="$3"
  local status_file="$BATCHES_DIR/${batch_id}.status.json"

  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  python3 - "$status_file" "$sub_id" "$new_status" "$timestamp" <<'PYEOF'
import json
import sys

status_file, sub_id, new_status, timestamp = sys.argv[1:5]

with open(status_file) as f:
    data = json.load(f)

if sub_id not in data["sub_batches"]:
    print(f"ERROR: Sub-batch {sub_id} not found", file=sys.stderr)
    sys.exit(1)

data["sub_batches"][sub_id]["status"] = new_status
if new_status == "approved":
    data["sub_batches"][sub_id]["approved_at"] = timestamp
elif new_status == "pending_review":
    data["sub_batches"][sub_id]["completed_at"] = timestamp

with open(status_file, "w") as f:
    json.dump(data, f, indent=2)
    f.write("\n")
PYEOF
}

# Approve sub-batch
approve_sub_batch() {
  local sub_id="$1"
  local batch_id
  batch_id=$(get_batch_id "$sub_id")

  if [[ "$DRY_RUN" == true ]]; then
    echo "[DRY RUN] Would mark $sub_id as approved"
    return 0
  fi

  update_status "$batch_id" "$sub_id" "approved"

  # Remove symlink view folder
  local view_dir="$VIEWS_DIR/$batch_id/$sub_id"
  if [[ -d "$view_dir" ]]; then
    echo "Removing view folder: $view_dir"
    rm -rf "$view_dir"
  fi

  # Also clean old-style view folder if exists
  local old_view_dir="$DATA_DIR/$sub_id"
  if [[ -d "$old_view_dir" ]]; then
    rm -rf "$old_view_dir"
  fi

  echo "Approved: $sub_id"
}

validate_sub_batch() {
  local sub_id="$1"
  local manifest="$BATCHES_DIR/${sub_id}.txt"
  if [[ ! -f "$manifest" ]]; then
    error "Sub-batch manifest not found: $manifest"
  fi

  local rc=0
  local -a validate_args=(--manifest "$manifest")
  local stage_reports_dir=""
  local waiver_file="$VALIDATE_WAIVER_FILE"

  if [[ -z "$waiver_file" ]]; then
    local auto_waiver="$WAIVERS_DIR/${sub_id}.json"
    if [[ -f "$auto_waiver" ]]; then
      waiver_file="$auto_waiver"
      echo "Using auto-detected waiver file: $waiver_file"
    fi
  fi

  if [[ "$VALIDATE_STAGE08_REPORT" == true ]]; then
    validate_args+=(--check-stage08-report)
  fi
  if [[ "$VALIDATE_STAGE09_CHUNKS" == true ]]; then
    validate_args+=(--check-stage09-chunks)
  fi
  if [[ -n "$waiver_file" ]]; then
    validate_args+=(--waiver-file "$waiver_file")
  fi
  if [[ "$VALIDATE_EMIT_STAGE_REPORTS" == true ]]; then
    validate_args+=(--emit-stage-reports)
    if [[ -n "$VALIDATE_STAGE_REPORTS_DIR" ]]; then
      if [[ "$VALIDATE_STAGE_REPORTS_DIR" = /* ]]; then
        stage_reports_dir="$VALIDATE_STAGE_REPORTS_DIR"
      else
        stage_reports_dir="$REPO_ROOT/$VALIDATE_STAGE_REPORTS_DIR"
      fi
    else
      stage_reports_dir="$REPO_ROOT/data/validation/stage_reports/$sub_id"
    fi
  fi
  if [[ -n "$VALIDATE_STAGE_REPORTS_DIR" ]]; then
    validate_args+=(--stage-reports-dir "$VALIDATE_STAGE_REPORTS_DIR")
  fi

  echo ""
  echo "=== Validations: $sub_id ==="
  echo ""

  python3 "$REPO_ROOT/scripts/training-data/validation/validate_manifest.py" "${validate_args[@]}" || rc=$?

  if [[ "$VALIDATE_EMIT_STAGE_REPORTS" == true ]]; then
    echo ""
    echo "=== Stage Report Contract Validation ==="
    echo ""
    python3 "$REPO_ROOT/scripts/training-data/validation/validate_stage_report.py" \
      --dir "$stage_reports_dir" \
      --manifest "$manifest" \
      --emit-readiness-summary || rc=$?
  fi

  echo ""
  echo "=== Batch Report (manifest-filtered) ==="
  echo ""
  python3 "$REPO_ROOT/scripts/training-data/validation/batch_report.py" --all --manifest "$manifest" --batch-id "$sub_id" --no-write || rc=$?

  return "$rc"
}

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    --list)
      MODE="list"
      shift
      ;;
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    --status)
      MODE="status"
      shift
      ;;
    --view)
      MODE="view"
      shift
      ;;
    --approve)
      MODE="approve"
      shift
      ;;
    --validate)
      MODE="validate"
      shift
      ;;
    --check-stage08-report)
      VALIDATE_STAGE08_REPORT=true
      shift
      ;;
    --check-stage09-chunks)
      VALIDATE_STAGE09_CHUNKS=true
      shift
      ;;
    --validate-deep)
      VALIDATE_STAGE08_REPORT=true
      VALIDATE_STAGE09_CHUNKS=true
      shift
      ;;
    --waiver-file)
      [[ $# -lt 2 ]] && error "--waiver-file requires a path"
      VALIDATE_WAIVER_FILE="$2"
      shift 2
      ;;
    --waiver-file=*)
      VALIDATE_WAIVER_FILE="${1#--waiver-file=}"
      shift
      ;;
    --emit-stage-reports)
      VALIDATE_EMIT_STAGE_REPORTS=true
      shift
      ;;
    --stage-reports-dir)
      [[ $# -lt 2 ]] && error "--stage-reports-dir requires a path"
      VALIDATE_STAGE_REPORTS_DIR="$2"
      shift 2
      ;;
    --stage-reports-dir=*)
      VALIDATE_STAGE_REPORTS_DIR="${1#--stage-reports-dir=}"
      shift
      ;;
    --stage)
      MODE="run_stage"
      STAGE="$2"
      shift 2
      ;;
    --stage=*)
      MODE="run_stage"
      STAGE="${1#--stage=}"
      shift
      ;;
    -*)
      error "Unknown option: $1"
      ;;
    *)
      if [[ -z "$SUB_BATCH_ID" ]]; then
        SUB_BATCH_ID="$1"
      else
        error "Unexpected argument: $1"
      fi
      shift
      ;;
  esac
done

# Handle --list (no sub-batch needed)
if [[ "$MODE" == "list" ]]; then
  list_batches
  exit 0
fi

# Require sub-batch ID for other modes
if [[ -z "$SUB_BATCH_ID" ]]; then
  usage
  exit 1
fi

# Determine if this is a batch ID or sub-batch ID
if is_sub_batch "$SUB_BATCH_ID"; then
  BATCH_ID=$(get_batch_id "$SUB_BATCH_ID")
else
  BATCH_ID="$SUB_BATCH_ID"
fi

# Execute based on mode
case "$MODE" in
  status)
    if is_sub_batch "$SUB_BATCH_ID"; then
      show_sub_batch_status "$SUB_BATCH_ID"
    else
      show_batch_status "$BATCH_ID"
    fi
    ;;
  run_stage)
    if ! is_sub_batch "$SUB_BATCH_ID"; then
      error "--stage requires a sub-batch ID (e.g., P001.1)"
    fi
    run_stage "$SUB_BATCH_ID" "$STAGE"
    ;;
  view)
    if ! is_sub_batch "$SUB_BATCH_ID"; then
      error "--view requires a sub-batch ID (e.g., P001.1)"
    fi
    create_full_view "$SUB_BATCH_ID"
    ;;
  approve)
    if ! is_sub_batch "$SUB_BATCH_ID"; then
      error "--approve requires a sub-batch ID (e.g., P001.1)"
    fi
    approve_sub_batch "$SUB_BATCH_ID"
    ;;
  validate)
    if ! is_sub_batch "$SUB_BATCH_ID"; then
      error "--validate requires a sub-batch ID (e.g., P001.1)"
    fi
    validate_sub_batch "$SUB_BATCH_ID"
    ;;
  *)
    # Default: show status
    if is_sub_batch "$SUB_BATCH_ID"; then
      show_sub_batch_status "$SUB_BATCH_ID"
    else
      show_batch_status "$BATCH_ID"
    fi
    ;;
esac
