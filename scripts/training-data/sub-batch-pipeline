#!/usr/bin/env bash
#
# scripts/training-data/sub-batch-pipeline
#
# Stage-by-stage pipeline orchestrator for sub-batches.
# Run ONE stage at a time, review, then continue.
#
# Usage:
#   A) List all batches:
#      ./sub-batch-pipeline --list
#
#   B) Show status of a sub-batch (per-stage breakdown):
#      ./sub-batch-pipeline P001.1 --status
#
#   C) Run a single stage:
#      ./sub-batch-pipeline P001.1 --stage 06
#      ./sub-batch-pipeline P001.1 --stage 06b
#
#   D) Create symlink view for browsing:
#      ./sub-batch-pipeline P001.1 --view
#
#   E) Mark sub-batch as approved:
#      ./sub-batch-pipeline P001.1 --approve
#
#   F) Show batch-level status:
#      ./sub-batch-pipeline P001 --status

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
cd "$REPO_ROOT"

BATCHES_DIR="$REPO_ROOT/docs/pipeline/batches"
DATA_DIR="$REPO_ROOT/data"

# Stage definitions
declare -A STAGE_DIRS=(
  ["06"]="06.video-type"
  ["06b"]="06b.verify"
  ["06c"]="06c.patched"
  ["07"]="07.content"
)
declare -A STAGE_SCRIPTS=(
  ["06"]="$REPO_ROOT/scripts/training-data/06.video-type"
  ["06b"]="$REPO_ROOT/scripts/training-data/06b.verify"
  ["06c"]="$REPO_ROOT/scripts/training-data/06c.patch"
  ["07"]="$REPO_ROOT/scripts/training-data/07.content"
)
declare -A STAGE_PATTERNS=(
  ["06"]="*.conversations.json"
  ["06b"]="*.verification.json"
  ["06c"]="*.conversations.json"
  ["07"]="*.enriched.json"
)
STAGE_ORDER=("06" "06b" "06c" "07")

# Modes
MODE=""
DRY_RUN=false
STAGE=""
SUB_BATCH_ID=""
BATCH_ID=""

usage() {
  cat <<'EOF'
Usage:
  ./sub-batch-pipeline --list                    List all batches and sub-batches
  ./sub-batch-pipeline P001.1 --status           Per-stage status with file paths
  ./sub-batch-pipeline P001.1 --stage 06         Run stage 06 only
  ./sub-batch-pipeline P001.1 --stage 06b        Run stage 06b only
  ./sub-batch-pipeline P001.1 --view             Create symlink view in data/P001.1/
  ./sub-batch-pipeline P001.1 --approve          Mark as approved
  ./sub-batch-pipeline P001 --status             Batch-level status

Options:
  --dry-run    Preview without running
EOF
}

error() {
  echo "ERROR: $*" >&2
  exit 1
}

# Extract batch ID from sub-batch ID (P001.1 -> P001)
get_batch_id() {
  local sub_id="$1"
  echo "${sub_id%.*}"
}

# Check if argument looks like a sub-batch (has .N suffix)
is_sub_batch() {
  [[ "$1" =~ \.[0-9]+$ ]]
}

# Extract video ID from filename/path
extract_video_id() {
  local name="$1"
  if [[ "$name" =~ \[([a-zA-Z0-9_-]{11})\] ]]; then
    echo "${BASH_REMATCH[1]}"
  fi
}

# Load manifest video IDs
load_manifest_ids() {
  local manifest="$1"
  grep -v "^#" "$manifest" | while read -r line; do
    extract_video_id "$line"
  done
}

# List all batches
list_batches() {
  echo ""
  echo "=== All Batches ==="
  echo ""

  for status_file in "$BATCHES_DIR"/*.status.json; do
    [[ -f "$status_file" ]] || continue
    python3 - "$status_file" <<'PYEOF'
import json
import sys

with open(sys.argv[1]) as f:
    data = json.load(f)

batch_id = data["batch_id"]
total = data["total_videos"]
sub_count = len(data["sub_batches"])

# Count statuses
counts = {"approved": 0, "pending_review": 0, "in_progress": 0, "not_started": 0}
for info in data["sub_batches"].values():
    counts[info["status"]] = counts.get(info["status"], 0) + 1

print(f"{batch_id}: {total} videos in {sub_count} sub-batches")
print(f"  approved: {counts['approved']}, pending: {counts['pending_review']}, in_progress: {counts['in_progress']}, not_started: {counts['not_started']}")
PYEOF
  done

  # List batches without status files (not yet split)
  for batch_file in "$BATCHES_DIR"/P*.txt; do
    [[ -f "$batch_file" ]] || continue
    batch_name=$(basename "$batch_file" .txt)
    # Skip sub-batch files (have dots)
    [[ "$batch_name" =~ \. ]] && continue
    status_file="$BATCHES_DIR/${batch_name}.status.json"
    if [[ ! -f "$status_file" ]]; then
      count=$(grep -v "^#" "$batch_file" | grep -c . || echo 0)
      echo "$batch_name: $count videos (not split yet - run sub-batch-create)"
    fi
  done
}

# Show per-stage status for a sub-batch
show_sub_batch_status() {
  local sub_id="$1"
  local batch_id
  batch_id=$(get_batch_id "$sub_id")

  local manifest="$BATCHES_DIR/${sub_id}.txt"
  if [[ ! -f "$manifest" ]]; then
    error "Sub-batch manifest not found: $manifest"
  fi

  # Get video IDs from manifest
  local -a video_ids=()
  while IFS='|' read -r source folder || [[ -n "$source" ]]; do
    [[ "$source" =~ ^# ]] && continue
    [[ -z "$source" ]] && continue
    source=$(echo "$source" | xargs)
    folder=$(echo "$folder" | xargs)
    vid_id=$(extract_video_id "$folder")
    [[ -n "$vid_id" ]] && video_ids+=("$vid_id:$source:$folder")
  done < "$manifest"

  local total=${#video_ids[@]}

  echo ""
  echo "=== Sub-batch $sub_id Status ($total videos) ==="
  echo ""

  for stage in "${STAGE_ORDER[@]}"; do
    local stage_dir="${STAGE_DIRS[$stage]}"
    local pattern="${STAGE_PATTERNS[$stage]}"
    local found=0
    local missing=()

    for entry in "${video_ids[@]}"; do
      IFS=':' read -r vid_id source folder <<< "$entry"

      # Check if output exists for this video
      local found_file=false

      # Search in stage directory
      if [[ -d "$DATA_DIR/$stage_dir" ]]; then
        while IFS= read -r -d '' f; do
          found_file=true
          break
        done < <(find "$DATA_DIR/$stage_dir" -name "*${vid_id}*" -name "$pattern" -print0 2>/dev/null)
      fi

      if [[ "$found_file" == true ]]; then
        ((found++))
      else
        missing+=("$folder")
      fi
    done

    local status_icon="â¬œ"
    if [[ $found -eq $total ]]; then
      status_icon="âœ…"
    elif [[ $found -gt 0 ]]; then
      status_icon="ðŸ”¶"
    fi

    printf "  %s Stage %s: %d/%d\n" "$status_icon" "$stage" "$found" "$total"

    # Show missing files if partially complete
    if [[ $found -gt 0 && $found -lt $total && ${#missing[@]} -le 5 ]]; then
      for m in "${missing[@]}"; do
        echo "      missing: $m"
      done
    elif [[ ${#missing[@]} -gt 5 ]]; then
      echo "      (${#missing[@]} missing)"
    fi
  done

  echo ""

  # Show current status from status file
  local status_file="$BATCHES_DIR/${batch_id}.status.json"
  if [[ -f "$status_file" ]]; then
    python3 - "$status_file" "$sub_id" <<'PYEOF'
import json
import sys

with open(sys.argv[1]) as f:
    data = json.load(f)

sub_id = sys.argv[2]
info = data["sub_batches"].get(sub_id, {})
status = info.get("status", "unknown")
print(f"Overall status: {status}")
PYEOF
  fi
}

# Show batch-level status (all sub-batches)
show_batch_status() {
  local batch_id="$1"
  local status_file="$BATCHES_DIR/${batch_id}.status.json"

  if [[ ! -f "$status_file" ]]; then
    error "Status file not found: $status_file (run sub-batch-create first)"
  fi

  python3 - "$status_file" <<'PYEOF'
import json
import sys

with open(sys.argv[1]) as f:
    data = json.load(f)

print(f"\nBatch {data['batch_id']} Status")
print(f"Total videos: {data['total_videos']}")
print(f"Sub-batch size: {data['sub_batch_size']}")
print()

status_symbols = {
    "approved": "\u2705",
    "pending_review": "\U0001F50D",
    "in_progress": "\u23F3",
    "not_started": "\u2B1C",
}

for sub_id in sorted(data["sub_batches"].keys(), key=lambda x: int(x.split(".")[-1])):
    info = data["sub_batches"][sub_id]
    status = info["status"]
    symbol = status_symbols.get(status, "?")
    count = info.get("video_count", "?")
    print(f"  {symbol} {sub_id}: {status} ({count} videos)")

# Summary
counts = {}
for info in data["sub_batches"].values():
    s = info["status"]
    counts[s] = counts.get(s, 0) + info.get("video_count", 0)

print()
print("Summary:")
for status in ["approved", "pending_review", "in_progress", "not_started"]:
    if status in counts:
        print(f"  {status}: {counts[status]} videos")
PYEOF
}

# Run a single stage
run_stage() {
  local sub_id="$1"
  local stage="$2"
  local batch_id
  batch_id=$(get_batch_id "$sub_id")

  local manifest="$BATCHES_DIR/${sub_id}.txt"
  if [[ ! -f "$manifest" ]]; then
    error "Sub-batch manifest not found: $manifest"
  fi

  local script="${STAGE_SCRIPTS[$stage]:-}"
  if [[ -z "$script" ]]; then
    error "Unknown stage: $stage (valid: ${STAGE_ORDER[*]})"
  fi

  local stage_dir="${STAGE_DIRS[$stage]}"

  echo ""
  echo "=== Running Stage $stage for $sub_id ==="
  echo ""

  if [[ "$DRY_RUN" == true ]]; then
    echo "[DRY RUN] Would run: $script --manifest $manifest"
    return 0
  fi

  # Update status to in_progress
  local status_file="$BATCHES_DIR/${batch_id}.status.json"
  if [[ -f "$status_file" ]]; then
    python3 - "$status_file" "$sub_id" "$stage" <<'PYEOF'
import json
import sys

status_file, sub_id, stage = sys.argv[1:4]

with open(status_file) as f:
    data = json.load(f)

if sub_id in data["sub_batches"]:
    data["sub_batches"][sub_id]["status"] = "in_progress"
    data["sub_batches"][sub_id]["current_stage"] = stage

with open(status_file, "w") as f:
    json.dump(data, f, indent=2)
    f.write("\n")
PYEOF
  fi

  # Run the stage
  if "$script" --manifest "$manifest"; then
    echo ""
    echo "Stage $stage: COMPLETE"

    # Create symlink view
    create_stage_view "$sub_id" "$stage"

    return 0
  else
    echo ""
    echo "Stage $stage: FAILED (some videos may have errors)"
    return 1
  fi
}

# Create symlink view for a stage
create_stage_view() {
  local sub_id="$1"
  local stage="$2"

  local view_dir="$DATA_DIR/$sub_id/$stage"
  local stage_dir="${STAGE_DIRS[$stage]}"
  local pattern="${STAGE_PATTERNS[$stage]}"
  local manifest="$BATCHES_DIR/${sub_id}.txt"

  mkdir -p "$view_dir"

  # Get video IDs from manifest
  while IFS='|' read -r source folder || [[ -n "$source" ]]; do
    [[ "$source" =~ ^# ]] && continue
    [[ -z "$source" ]] && continue
    source=$(echo "$source" | xargs)
    folder=$(echo "$folder" | xargs)
    vid_id=$(extract_video_id "$folder")
    [[ -z "$vid_id" ]] && continue

    # Find matching files and create symlinks
    while IFS= read -r -d '' f; do
      local rel_path="${f#$DATA_DIR/$stage_dir/}"
      local link_name=$(basename "$f")

      # Create symlink if not exists
      if [[ ! -L "$view_dir/$link_name" ]]; then
        ln -sf "$f" "$view_dir/$link_name" 2>/dev/null || true
      fi
    done < <(find "$DATA_DIR/$stage_dir" -name "*${vid_id}*" -name "$pattern" -print0 2>/dev/null)
  done < "$manifest"

  local count=$(find "$view_dir" -type l 2>/dev/null | wc -l)
  echo "  View: $view_dir ($count files)"
}

# Create full symlink view for all stages
create_full_view() {
  local sub_id="$1"

  echo ""
  echo "=== Creating View for $sub_id ==="

  for stage in "${STAGE_ORDER[@]}"; do
    create_stage_view "$sub_id" "$stage"
  done

  echo ""
  echo "Browse: $DATA_DIR/$sub_id/"
}

# Update status
update_status() {
  local batch_id="$1"
  local sub_id="$2"
  local new_status="$3"
  local status_file="$BATCHES_DIR/${batch_id}.status.json"

  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  python3 - "$status_file" "$sub_id" "$new_status" "$timestamp" <<'PYEOF'
import json
import sys

status_file, sub_id, new_status, timestamp = sys.argv[1:5]

with open(status_file) as f:
    data = json.load(f)

if sub_id not in data["sub_batches"]:
    print(f"ERROR: Sub-batch {sub_id} not found", file=sys.stderr)
    sys.exit(1)

data["sub_batches"][sub_id]["status"] = new_status
if new_status == "approved":
    data["sub_batches"][sub_id]["approved_at"] = timestamp
elif new_status == "pending_review":
    data["sub_batches"][sub_id]["completed_at"] = timestamp

with open(status_file, "w") as f:
    json.dump(data, f, indent=2)
    f.write("\n")
PYEOF
}

# Approve sub-batch
approve_sub_batch() {
  local sub_id="$1"
  local batch_id
  batch_id=$(get_batch_id "$sub_id")

  if [[ "$DRY_RUN" == true ]]; then
    echo "[DRY RUN] Would mark $sub_id as approved"
    return 0
  fi

  update_status "$batch_id" "$sub_id" "approved"

  # Remove symlink view folder
  local view_dir="$DATA_DIR/$sub_id"
  if [[ -d "$view_dir" ]]; then
    echo "Removing view folder: $view_dir"
    rm -rf "$view_dir"
  fi

  echo "Approved: $sub_id"
}

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    --list)
      MODE="list"
      shift
      ;;
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    --status)
      MODE="status"
      shift
      ;;
    --view)
      MODE="view"
      shift
      ;;
    --approve)
      MODE="approve"
      shift
      ;;
    --stage)
      MODE="run_stage"
      STAGE="$2"
      shift 2
      ;;
    --stage=*)
      MODE="run_stage"
      STAGE="${1#--stage=}"
      shift
      ;;
    -*)
      error "Unknown option: $1"
      ;;
    *)
      if [[ -z "$SUB_BATCH_ID" ]]; then
        SUB_BATCH_ID="$1"
      else
        error "Unexpected argument: $1"
      fi
      shift
      ;;
  esac
done

# Handle --list (no sub-batch needed)
if [[ "$MODE" == "list" ]]; then
  list_batches
  exit 0
fi

# Require sub-batch ID for other modes
if [[ -z "$SUB_BATCH_ID" ]]; then
  usage
  exit 1
fi

# Determine if this is a batch ID or sub-batch ID
if is_sub_batch "$SUB_BATCH_ID"; then
  BATCH_ID=$(get_batch_id "$SUB_BATCH_ID")
else
  BATCH_ID="$SUB_BATCH_ID"
fi

# Execute based on mode
case "$MODE" in
  status)
    if is_sub_batch "$SUB_BATCH_ID"; then
      show_sub_batch_status "$SUB_BATCH_ID"
    else
      show_batch_status "$BATCH_ID"
    fi
    ;;
  run_stage)
    if ! is_sub_batch "$SUB_BATCH_ID"; then
      error "--stage requires a sub-batch ID (e.g., P001.1)"
    fi
    run_stage "$SUB_BATCH_ID" "$STAGE"
    ;;
  view)
    if ! is_sub_batch "$SUB_BATCH_ID"; then
      error "--view requires a sub-batch ID (e.g., P001.1)"
    fi
    create_full_view "$SUB_BATCH_ID"
    ;;
  approve)
    if ! is_sub_batch "$SUB_BATCH_ID"; then
      error "--approve requires a sub-batch ID (e.g., P001.1)"
    fi
    approve_sub_batch "$SUB_BATCH_ID"
    ;;
  *)
    # Default: show status
    if is_sub_batch "$SUB_BATCH_ID"; then
      show_sub_batch_status "$SUB_BATCH_ID"
    else
      show_batch_status "$BATCH_ID"
    fi
    ;;
esac
