#!/usr/bin/env python3
"""
scripts/training-data/DET.split-manifest

Split a manifest into infield and non-infield sub-manifests based on Stage 06 output.

After Stage 06 completes, this script reads each video's .conversations.json to count
approach conversations (conversation_id > 0). Videos with 1+ approaches go into the
infield manifest; videos with 0 approaches go into the non-infield manifest.

Usage:
  ./scripts/training-data/DET.split-manifest --manifest docs/pipeline/batches/CANARY.1.txt
  ./scripts/training-data/DET.split-manifest --manifest docs/pipeline/batches/CANARY.1.txt --stage06-root data/06.LLM.video-type

Output:
  docs/pipeline/batches/CANARY.1.infield.txt
  docs/pipeline/batches/CANARY.1.non_infield.txt
"""

from __future__ import annotations

import argparse
import json
import re
import sys
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple


def repo_root() -> Path:
    return Path(__file__).resolve().parent.parent.parent


def extract_video_id(name: str) -> Optional[str]:
    match = re.search(r"\[([A-Za-z0-9_-]{11})\]", name)
    return match.group(1) if match else None


def parse_manifest_lines(manifest_path: Path) -> List[Tuple[str, str, str]]:
    """Parse manifest into (source, folder, video_id) tuples. Preserves order."""
    entries: List[Tuple[str, str, str]] = []
    with manifest_path.open("r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            parts = line.split("|", 1)
            if len(parts) != 2:
                continue
            src = parts[0].strip()
            folder = parts[1].strip()
            vid_id = extract_video_id(folder)
            if vid_id:
                entries.append((src, folder, vid_id))
    return entries


def find_conversations_file(
    source: str,
    video_id: str,
    stage06_root: Path,
) -> Optional[Path]:
    """Find the .conversations.json file for a video in Stage 06 output.

    Checks source-video layout first, then root-flat fallback.
    """
    # Source-video layout: data/06.LLM.video-type/<source>/*[video_id]*.conversations.json
    src_dir = stage06_root / source
    if src_dir.exists():
        for f in src_dir.rglob("*.conversations.json"):
            if f"[{video_id}]" in f.name and not f.name.endswith(".validation.json"):
                return f

    # Root-flat fallback: data/06.LLM.video-type/*[video_id]*.conversations.json
    for f in stage06_root.glob("*.conversations.json"):
        if f"[{video_id}]" in f.name and not f.name.endswith(".validation.json"):
            return f

    return None


def count_approaches(conversations_path: Path) -> int:
    """Count distinct approach conversations (conversation_id > 0) in a Stage 06 file."""
    with conversations_path.open("r", encoding="utf-8") as f:
        data = json.load(f)
    segments = data.get("segments", [])
    return len({
        seg.get("conversation_id")
        for seg in segments
        if isinstance(seg.get("conversation_id"), int) and seg["conversation_id"] > 0
    })


def write_manifest(
    path: Path,
    entries: List[Tuple[str, str, str]],
    label: str,
    original_manifest: str,
) -> None:
    """Write a sub-manifest file."""
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as f:
        f.write(f"# {label} split from {original_manifest}\n")
        f.write(f"# Videos: {len(entries)}\n")
        f.write(f"# Generated by: scripts/training-data/DET.split-manifest\n")
        f.write(f"#\n")
        f.write(f"# Format: source_name | video_folder_name\n")
        for src, folder, _ in entries:
            f.write(f"{src} | {folder}\n")


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Split a manifest into infield and non-infield sub-manifests based on Stage 06 output."
    )
    parser.add_argument(
        "--manifest",
        required=True,
        help="Path to the manifest file to split.",
    )
    parser.add_argument(
        "--stage06-root",
        default="data/06.LLM.video-type",
        help="Root directory for Stage 06 output (default: data/06.LLM.video-type).",
    )
    parser.add_argument(
        "--output-dir",
        help="Output directory for split manifests (default: same directory as input manifest).",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print routing decisions without writing files.",
    )

    args = parser.parse_args()

    manifest_path = Path(args.manifest)
    if not manifest_path.is_absolute():
        manifest_path = repo_root() / manifest_path
    if not manifest_path.exists():
        raise SystemExit(f"Manifest not found: {manifest_path}")

    stage06_root = Path(args.stage06_root)
    if not stage06_root.is_absolute():
        stage06_root = repo_root() / stage06_root

    entries = parse_manifest_lines(manifest_path)
    if not entries:
        raise SystemExit(f"No entries found in manifest: {manifest_path}")

    infield: List[Tuple[str, str, str]] = []
    non_infield: List[Tuple[str, str, str]] = []
    missing: List[Tuple[str, str, str]] = []

    for src, folder, vid_id in entries:
        conv_file = find_conversations_file(src, vid_id, stage06_root)
        if not conv_file:
            missing.append((src, folder, vid_id))
            continue

        n_approaches = count_approaches(conv_file)
        lane = "infield" if n_approaches > 0 else "non_infield"

        if lane == "infield":
            infield.append((src, folder, vid_id))
        else:
            non_infield.append((src, folder, vid_id))

        print(f"  {vid_id}  approaches={n_approaches}  → {lane}")

    print()
    print(f"Summary: {len(infield)} infield, {len(non_infield)} non_infield, {len(missing)} missing Stage 06 data")

    if missing:
        print(f"\nMissing Stage 06 data (not routed):")
        for src, folder, vid_id in missing:
            print(f"  {src} | {folder}")

    if args.dry_run:
        print("\n[DRY RUN] No files written.")
        return

    # Determine output paths
    manifest_stem = manifest_path.stem
    out_dir = Path(args.output_dir) if args.output_dir else manifest_path.parent

    infield_path = out_dir / f"{manifest_stem}.infield.txt"
    non_infield_path = out_dir / f"{manifest_stem}.non_infield.txt"

    if infield:
        write_manifest(infield_path, infield, "Infield", manifest_path.name)
        print(f"\nWrote: {infield_path} ({len(infield)} videos)")
    else:
        print(f"\nNo infield videos — {infield_path} not written.")

    if non_infield:
        write_manifest(non_infield_path, non_infield, "Non-infield", manifest_path.name)
        print(f"Wrote: {non_infield_path} ({len(non_infield)} videos)")
    else:
        print(f"No non-infield videos — {non_infield_path} not written.")


if __name__ == "__main__":
    main()
