#!/usr/bin/env bash
#
# scripts/training-data/batches
#
# Unified batch pipeline runner. Runs stages 02-07 for sub-batches and
# automatically creates symlink views in batch-views/.
#
# Usage:
#   ./batches status                    # Show all batch progress
#   ./batches status P001               # Show P001 sub-batch status
#   ./batches status P001.1             # Show P001.1 stage-by-stage status
#
#   ./batches run P001.1 02             # Run stage 02 for P001.1
#   ./batches run P001.1 02-05          # Run stages 02 through 05
#   ./batches run P001.1 all            # Run all stages (02-07)
#
#   ./batches next P001                 # Run next incomplete sub-batch
#   ./batches next P001 --count 3       # Run next 3 incomplete sub-batches
#
# After each stage, symlink views are created in batch-views/<batch>/<sub-batch>/
#
# CLAUDE INSTRUCTIONS:
# To run the next N batches, use: ./batches next P001 --count N
# To run specific stages: ./batches run P001.X 02-07
# Always check status first: ./batches status P001

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
cd "$REPO_ROOT"

BATCHES_DIR="$REPO_ROOT/docs/pipeline/batches"
DATA_DIR="$REPO_ROOT/data"
VIEWS_DIR="$REPO_ROOT/batch-views"

# All stages in order
ALL_STAGES=("02" "03" "04" "05" "06" "06b" "06c" "07")

# Stage directories and patterns
declare -A STAGE_DIRS=(
  ["01"]="01.download"
  ["02"]="02.transcribe"
  ["03"]="03.align"
  ["04"]="04.diarize"
  ["05"]="05.audio-features"
  ["06"]="06.video-type"
  ["06b"]="06b.verify"
  ["06c"]="06c.patched"
  ["07"]="07.content"
)

declare -A STAGE_PATTERNS=(
  ["01"]="*.wav"
  ["02"]="*.full.json"
  ["03"]="*.full.json"
  ["04"]="*.full.json"
  ["05"]="*.audio_features.json"
  ["06"]="*.conversations.json"
  ["06b"]="*.verification.json"
  ["06c"]="*.conversations.json"
  ["07"]="*.enriched.json"
)

# Stage scripts
declare -A STAGE_SCRIPTS=(
  ["02"]="$SCRIPT_DIR/02.transcribe"
  ["03"]="$SCRIPT_DIR/03.align"
  ["04"]="$SCRIPT_DIR/04.diarize"
  ["05"]="$SCRIPT_DIR/05.audio-features"
  ["06"]="$SCRIPT_DIR/06.video-type"
  ["06b"]="$SCRIPT_DIR/06b.verify"
  ["06c"]="$SCRIPT_DIR/06c.patch"
  ["07"]="$SCRIPT_DIR/07.content"
)

# Nested stages (source/video folder structure)
NESTED_STAGES=("01" "02" "03" "04" "05")

# ============================================================================
# Helpers
# ============================================================================

usage() {
  cat <<'EOF'
Usage:
  ./batches status                    Show all batch progress
  ./batches status P001               Show P001 sub-batch status
  ./batches status P001.1             Show P001.1 stage-by-stage status

  ./batches run P001.1 02             Run stage 02 for P001.1
  ./batches run P001.1 02-05          Run stages 02 through 05
  ./batches run P001.1 all            Run all stages (02-07)

  ./batches next P001                 Run next incomplete sub-batch (all stages)
  ./batches next P001 --count 3       Run next 3 incomplete sub-batches

Options:
  --dry-run    Preview without running

Symlink views are auto-created in batch-views/<batch>/<sub-batch>/ after each stage.
EOF
}

error() {
  echo "ERROR: $*" >&2
  exit 1
}

get_batch_id() {
  local sub_id="$1"
  echo "${sub_id%.*}"
}

is_sub_batch() {
  [[ "$1" =~ \.[0-9]+$ ]]
}

extract_video_id() {
  local name="$1"
  if [[ "$name" =~ \[([a-zA-Z0-9_-]{11})\] ]]; then
    echo "${BASH_REMATCH[1]}"
  fi
}

is_nested_stage() {
  local stage="$1"
  for s in "${NESTED_STAGES[@]}"; do
    [[ "$s" == "$stage" ]] && return 0
  done
  return 1
}

# ============================================================================
# Symlink View Creation
# ============================================================================

create_stage_view() {
  local sub_id="$1"
  local stage="$2"
  local batch_id
  batch_id=$(get_batch_id "$sub_id")

  local stage_dir="${STAGE_DIRS[$stage]:-}"
  [[ -z "$stage_dir" ]] && return 0

  local pattern="${STAGE_PATTERNS[$stage]}"
  local manifest="$BATCHES_DIR/${sub_id}.txt"
  local view_base="$VIEWS_DIR/$batch_id/$sub_id/$stage_dir"

  # Clear existing view for this stage
  rm -rf "$view_base" 2>/dev/null || true

  local link_count=0
  local pending_count=0

  # Process each video from manifest
  while IFS='|' read -r source folder || [[ -n "$source" ]]; do
    [[ "$source" =~ ^# ]] && continue
    [[ -z "$source" ]] && continue
    source="${source#"${source%%[![:space:]]*}"}"
    source="${source%"${source##*[![:space:]]}"}"
    folder="${folder#"${folder%%[![:space:]]*}"}"
    folder="${folder%"${folder##*[![:space:]]}"}"
    vid_id=$(extract_video_id "$folder")
    [[ -z "$vid_id" ]] && continue

    local video_view_dir="$view_base/$source/$folder"
    mkdir -p "$video_view_dir"

    local found_file=false

    if is_nested_stage "$stage"; then
      local src_video_dir="$DATA_DIR/$stage_dir/$source/$folder"
      if [[ -d "$src_video_dir" ]]; then
        while IFS= read -r -d '' f; do
          found_file=true
          local link_name
          link_name=$(basename "$f")
          local rel_target
          rel_target=$(realpath --relative-to="$video_view_dir" "$f")
          ln -sf "$rel_target" "$video_view_dir/$link_name" 2>/dev/null || true
          ((++link_count))
        done < <(find "$src_video_dir" -maxdepth 1 -type f -name "$pattern" -print0 2>/dev/null)
      fi
    else
      while IFS= read -r -d '' f; do
        found_file=true
        local link_name
        link_name=$(basename "$f")
        local rel_target
        rel_target=$(realpath --relative-to="$video_view_dir" "$f")
        ln -sf "$rel_target" "$video_view_dir/$link_name" 2>/dev/null || true
        ((++link_count))
      done < <(find "$DATA_DIR/$stage_dir" -maxdepth 1 -name "*${vid_id}*" -name "$pattern" -print0 2>/dev/null)
    fi

    if [[ "$found_file" == false ]]; then
      touch "$video_view_dir/.pending"
      ((++pending_count))
    fi
  done < "$manifest"

  echo "    [view] $stage_dir: $link_count files, $pending_count pending"
}

create_all_views() {
  local sub_id="$1"
  echo "  Creating symlink views..."
  for stage in "01" "${ALL_STAGES[@]}"; do
    create_stage_view "$sub_id" "$stage"
  done
}

# ============================================================================
# Stage Running
# ============================================================================

run_single_stage() {
  local sub_id="$1"
  local stage="$2"
  local dry_run="${3:-false}"

  local manifest="$BATCHES_DIR/${sub_id}.txt"
  if [[ ! -f "$manifest" ]]; then
    error "Manifest not found: $manifest"
  fi

  local script="${STAGE_SCRIPTS[$stage]:-}"
  if [[ -z "$script" ]]; then
    error "Unknown stage: $stage"
  fi

  echo "  Stage $stage: Running..."

  if [[ "$dry_run" == "true" ]]; then
    echo "    [DRY RUN] Would run: $script --manifest $manifest"
    return 0
  fi

  if "$script" --manifest "$manifest"; then
    echo "  Stage $stage: COMPLETE"
    create_stage_view "$sub_id" "$stage"
    return 0
  else
    echo "  Stage $stage: FAILED"
    return 1
  fi
}

parse_stage_range() {
  local range="$1"

  if [[ "$range" == "all" ]]; then
    echo "${ALL_STAGES[*]}"
    return
  fi

  if [[ "$range" =~ ^([0-9]+[a-z]?)-([0-9]+[a-z]?)$ ]]; then
    local start="${BASH_REMATCH[1]}"
    local end="${BASH_REMATCH[2]}"
    local in_range=false
    local stages=()

    for s in "${ALL_STAGES[@]}"; do
      if [[ "$s" == "$start" ]]; then
        in_range=true
      fi
      if [[ "$in_range" == true ]]; then
        stages+=("$s")
      fi
      if [[ "$s" == "$end" ]]; then
        break
      fi
    done
    echo "${stages[*]}"
    return
  fi

  # Single stage
  echo "$range"
}

run_stages() {
  local sub_id="$1"
  local stage_spec="$2"
  local dry_run="${3:-false}"
  local batch_id
  batch_id=$(get_batch_id "$sub_id")

  echo ""
  echo "=== Running $sub_id: stages $stage_spec ==="
  echo ""

  local stages
  stages=$(parse_stage_range "$stage_spec")

  for stage in $stages; do
    run_single_stage "$sub_id" "$stage" "$dry_run" || {
      echo "  Stopping due to stage $stage failure"
      return 1
    }
  done

  echo ""
  echo "=== $sub_id: Complete ==="
  echo "Browse: $VIEWS_DIR/$batch_id/$sub_id/"
}

# ============================================================================
# Status
# ============================================================================

show_all_status() {
  echo ""
  echo "=== All Batches ==="
  echo ""

  for status_file in "$BATCHES_DIR"/*.status.json; do
    [[ -f "$status_file" ]] || continue
    python3 - "$status_file" <<'PYEOF'
import json
import sys

with open(sys.argv[1]) as f:
    data = json.load(f)

batch_id = data["batch_id"]
total = data["total_videos"]
sub_count = len(data["sub_batches"])

counts = {"approved": 0, "pending_review": 0, "in_progress": 0, "not_started": 0}
for info in data["sub_batches"].values():
    counts[info["status"]] = counts.get(info["status"], 0) + 1

print(f"{batch_id}: {total} videos in {sub_count} sub-batches")
print(f"  approved: {counts['approved']}, pending: {counts['pending_review']}, in_progress: {counts['in_progress']}, not_started: {counts['not_started']}")
PYEOF
  done
}

show_batch_status() {
  local batch_id="$1"
  "$SCRIPT_DIR/sub-batch-pipeline" "$batch_id" --status
}

show_sub_batch_status() {
  local sub_id="$1"
  "$SCRIPT_DIR/batch-status" "$BATCHES_DIR/${sub_id}.txt"
}

# ============================================================================
# Next (run next incomplete sub-batches)
# ============================================================================

get_next_sub_batches() {
  local batch_id="$1"
  local count="${2:-1}"
  local status_file="$BATCHES_DIR/${batch_id}.status.json"

  if [[ ! -f "$status_file" ]]; then
    error "Status file not found: $status_file"
  fi

  python3 - "$status_file" "$count" <<'PYEOF'
import json
import sys

with open(sys.argv[1]) as f:
    data = json.load(f)

count = int(sys.argv[2])
found = 0

for sub_id in sorted(data["sub_batches"].keys(), key=lambda x: int(x.split(".")[-1])):
    info = data["sub_batches"][sub_id]
    if info["status"] in ("not_started", "in_progress"):
        print(sub_id)
        found += 1
        if found >= count:
            break
PYEOF
}

run_next() {
  local batch_id="$1"
  local count="${2:-1}"
  local dry_run="${3:-false}"

  local sub_batches
  sub_batches=$(get_next_sub_batches "$batch_id" "$count")

  if [[ -z "$sub_batches" ]]; then
    echo "No incomplete sub-batches found in $batch_id"
    return 0
  fi

  echo "Will run: $sub_batches"
  echo ""

  for sub_id in $sub_batches; do
    run_stages "$sub_id" "all" "$dry_run"
  done
}

# ============================================================================
# Main
# ============================================================================

DRY_RUN=false
CMD=""
TARGET=""
STAGE_SPEC=""
COUNT=1

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    --count)
      COUNT="$2"
      shift 2
      ;;
    status|run|next)
      CMD="$1"
      shift
      ;;
    *)
      if [[ -z "$TARGET" ]]; then
        TARGET="$1"
      elif [[ -z "$STAGE_SPEC" ]]; then
        STAGE_SPEC="$1"
      fi
      shift
      ;;
  esac
done

case "$CMD" in
  status)
    if [[ -z "$TARGET" ]]; then
      show_all_status
    elif is_sub_batch "$TARGET"; then
      show_sub_batch_status "$TARGET"
    else
      show_batch_status "$TARGET"
    fi
    ;;
  run)
    if [[ -z "$TARGET" ]] || [[ -z "$STAGE_SPEC" ]]; then
      error "Usage: ./batches run <sub-batch> <stage|range|all>"
    fi
    if ! is_sub_batch "$TARGET"; then
      error "run requires a sub-batch ID (e.g., P001.1)"
    fi
    run_stages "$TARGET" "$STAGE_SPEC" "$DRY_RUN"
    ;;
  next)
    if [[ -z "$TARGET" ]]; then
      error "Usage: ./batches next <batch> [--count N]"
    fi
    if is_sub_batch "$TARGET"; then
      error "next requires a batch ID (e.g., P001), not a sub-batch"
    fi
    run_next "$TARGET" "$COUNT" "$DRY_RUN"
    ;;
  *)
    usage
    exit 1
    ;;
esac
