#!/usr/bin/env python3
"""
Test variant of 07.LLM-conversations with multiple prompt strategies.

This script allows testing different prompt approaches to fix the
conversation classification quality issues.

Usage:
  python scripts/training-data/07.LLM-conversations-test --strategy A --input data/07.LLM-conversations-test/input --output data/07.LLM-conversations-test/strategy-a
"""

from __future__ import annotations

import argparse
import json
import os
import re
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Tuple

import requests


# ---------------------------
# Ollama configuration
# ---------------------------

OLLAMA_BASE_URL = os.environ.get("OLLAMA_API_URL", "http://localhost:11434")
OLLAMA_MODEL = os.environ.get("OLLAMA_MODEL", "llama3.1")


# ---------------------------
# Windowing (LLM batching)
# ---------------------------

WINDOW_SIZE = 10
WINDOW_OVERLAP = 3


@dataclass
class SegmentAnalysis:
    segment_type: str
    conversation_id: int
    is_new_conversation: bool
    confidence: float
    reasoning: str


def _call_ollama(prompt: str, retries: int = 3) -> Optional[str]:
    for attempt in range(retries):
        try:
            response = requests.post(
                f"{OLLAMA_BASE_URL}/api/generate",
                json={
                    "model": OLLAMA_MODEL,
                    "prompt": prompt,
                    "stream": False,
                    "options": {
                        "temperature": 0.3,
                        "num_predict": 500,
                    },
                },
                timeout=60,
            )
            if response.ok:
                return response.json().get("response", "")
        except requests.exceptions.RequestException as e:
            if attempt < retries - 1:
                time.sleep(1)
                continue
            print(f"[LLM_test] Ollama error: {e}")
    return None


# ---------------------------
# STRATEGY A: Detect video type first, then classify
# ---------------------------

def detect_video_type_with_llm(segments: List[Dict], video_title: str) -> str:
    """First pass: Determine if video is infield, talking_head, or podcast."""

    # Sample first 5, middle 5, last 5 segments
    sample_indices = list(range(min(5, len(segments))))
    if len(segments) > 10:
        mid = len(segments) // 2
        sample_indices += list(range(mid - 2, mid + 3))
    if len(segments) > 15:
        sample_indices += list(range(len(segments) - 5, len(segments)))

    sample_indices = sorted(set(i for i in sample_indices if 0 <= i < len(segments)))

    sample_texts = []
    for i in sample_indices[:15]:
        text = segments[i].get("text", "")[:100]
        sample_texts.append(f"[{i}] {text}")

    prompt = f"""Classify this video's content type based on the title and sample segments.

VIDEO TITLE: "{video_title}"

SAMPLE SEGMENTS:
{chr(10).join(sample_texts)}

Content types:
- "infield": Coach approaching women on the street. Contains ACTUAL openers like "excuse me, two seconds", real responses from women, number closes.
- "talking_head": Coach talking to camera about theory, tips, or experiences. No actual approaches happening.
- "podcast": Coach talking with a co-host or student in interview/discussion format. Two people discussing topics, NOT approaching women.

KEY DISTINCTION: In "infield", the coach is DOING approaches. In "talking_head" and "podcast", the coach is TALKING ABOUT approaches.

Respond with ONLY one of: infield, talking_head, podcast

Video type:"""

    response = _call_ollama(prompt)
    if response:
        response_lower = response.lower().strip()
        for vtype in ["infield", "talking_head", "podcast"]:
            if vtype in response_lower:
                return vtype
    return "unknown"


def strategy_a_prompt(segments_text: str, prev_type: str, conv_id: int, video_type: str) -> str:
    """Strategy A: Include video type context in prompt."""

    if video_type in ["talking_head", "podcast"]:
        context = f"""This is a {video_type.upper()} video - the coach is NOT approaching women in this video.
All dialogue is either coach talking to camera (talking_head) or coach talking to a co-host/student (podcast).
There should be ZERO "approach" segments in this video. Everything is "commentary"."""
    else:
        context = """This is INFIELD footage - the coach is actually approaching women on the street.
Look for real opener patterns, genuine responses from women, and number closes."""

    return f"""Analyze these transcript segments from a daygame coaching video.

VIDEO TYPE: {video_type.upper()}
{context}

Classify each segment as one of:
- "approach": ONLY for actual real-time conversation with a woman being approached (opener, vibing, number close)
- "commentary": Coach talking to camera, OR coach discussing theory with co-host, OR giving EXAMPLES of what to say
- "transition": Brief marker between sections

CRITICAL: If video type is talking_head or podcast, classify ALL segments as "commentary" or "transition".
Talking ABOUT approaches or giving example lines is commentary, not approach.

Previous segment type: {prev_type}
Current conversation ID: {conv_id}

Segments:
{segments_text}

Respond with ONLY a valid JSON array. Example:
[{{"index": 0, "type": "commentary", "new_conversation": false, "confidence": 0.9}}]

JSON response:"""


# ---------------------------
# STRATEGY B: Enhanced signals in prompt
# ---------------------------

def strategy_b_prompt(segments_text: str, prev_type: str, conv_id: int, video_title: str) -> str:
    """Strategy B: Add video title and stricter definitions."""

    return f"""Analyze these transcript segments from a daygame video.

VIDEO TITLE: "{video_title}"

CRITICAL DISTINCTION - What counts as "approach":
1. Coach MUST be speaking TO a woman he just met on the street
2. The woman MUST be responding in real-time
3. NOT: Coach giving examples of what to say
4. NOT: Coach discussing approaches with another man (co-host, student)
5. NOT: Coach explaining theory or techniques

Signs this is NOT an approach:
- Title contains: "Guide", "Advice", "Tips", "Mistakes", "How to", "Mindset", "Rant"
- Phrases like: "You guys", "As I always say", "The key here is", "Let me explain"
- Two male voices discussing/debating (this is podcast, not approach)
- Segment sounds like teaching/explaining (not natural conversation)

Classify each segment:
- "approach": Real-time dialogue with woman being approached
- "commentary": Everything else (theory, examples, discussion, explanation)
- "transition": Brief section markers

Previous segment type: {prev_type}
Current conversation ID: {conv_id}

Segments:
{segments_text}

Respond with ONLY valid JSON array. Example:
[{{"index": 0, "type": "commentary", "new_conversation": false, "confidence": 0.9}}]

JSON response:"""


# ---------------------------
# STRATEGY C: Two-pass with confirmation
# ---------------------------

def strategy_c_first_pass(segments_text: str) -> str:
    """Strategy C first pass: Conservative classification."""

    return f"""You are analyzing a daygame coaching video transcript.

TASK: For each segment, determine if it's DEFINITELY an approach or PROBABLY commentary.

Classify as "approach" ONLY if you see CLEAR evidence of:
- An opener to a woman ("excuse me", "I noticed you", "quick question")
- A woman's direct response to being approached
- Number close dialogue ("can I get your number")

If ANY doubt, classify as "commentary".

Segments:
{segments_text}

Respond with ONLY valid JSON array:
[{{"index": 0, "type": "commentary", "confidence": 0.9}}]

JSON response:"""


# ---------------------------
# STRATEGY D: Stricter definition with examples
# ---------------------------

def strategy_d_prompt(segments_text: str, prev_type: str, conv_id: int) -> str:
    """Strategy D: Provide clear examples of what IS and ISN'T an approach."""

    return f"""Classify these transcript segments from a daygame video.

APPROACH examples (real-time conversation with a woman):
- "Excuse me, two seconds, I know you're in a rush..."
- "Hey, I just noticed you walking by and had to say hi"
- "Hi, thanks" (woman responding)
- "What's your name?" "I'm Sarah"
- "Can I get your number?"

COMMENTARY examples (NOT approaches):
- "Hey guys, welcome back to the channel"
- "So what I like to do is..."
- "The key to a good opener is..."
- "Let's say you see a girl and you want to approach..."
- "What would you say in that situation, Jerry?"
- "I agree, that's a good point"

Classifications:
- "approach": Real conversation with woman (must have actual opener + response)
- "commentary": Teaching, explaining, discussing, giving examples
- "transition": Section markers

Previous: {prev_type}
Conv ID: {conv_id}

Segments:
{segments_text}

Respond with ONLY JSON array:
[{{"index": 0, "type": "commentary", "new_conversation": false, "confidence": 0.9}}]

JSON:"""


# ---------------------------
# STRATEGY E: Include video title
# ---------------------------

def strategy_e_prompt(segments_text: str, prev_type: str, conv_id: int, video_title: str) -> str:
    """Strategy E: Simple - just add video title for context."""

    # Detect likely content type from title
    title_lower = video_title.lower()
    likely_talking_head = any(x in title_lower for x in [
        "guide", "advice", "tips", "mistakes", "how to", "mindset", "rant",
        "motivation", "charisma", "communication", "texting", "messaging"
    ])

    if likely_talking_head:
        hint = "Based on the title, this is likely educational/talking-head content with NO real approaches."
    else:
        hint = "Based on the title, this may contain actual infield approaches."

    return f"""Classify segments from a daygame video.

VIDEO TITLE: "{video_title}"
HINT: {hint}

- "approach": Real dialogue with woman being approached on street
- "commentary": Coach explaining, teaching, or discussing with co-host
- "transition": Section markers

Previous: {prev_type}
Conv ID: {conv_id}

Segments:
{segments_text}

Respond with JSON array only:
[{{"index": 0, "type": "commentary", "new_conversation": false, "confidence": 0.9}}]

JSON:"""


# ---------------------------
# Main processing
# ---------------------------

def analyze_window(
    segments: List[Dict],
    start_idx: int,
    conv_id: int,
    prev_type: str,
    strategy: str,
    video_title: str = "",
    video_type: str = "unknown"
) -> List[SegmentAnalysis]:
    """Analyze a window of segments using the specified strategy."""

    window = segments[start_idx : start_idx + WINDOW_SIZE]

    segment_texts = []
    for i, seg in enumerate(window):
        text = seg.get("text", "").strip()
        segment_texts.append(f"[{i}] {text}")
    segments_text = chr(10).join(segment_texts)

    # Select prompt based on strategy
    if strategy == "A":
        prompt = strategy_a_prompt(segments_text, prev_type, conv_id, video_type)
    elif strategy == "B":
        prompt = strategy_b_prompt(segments_text, prev_type, conv_id, video_title)
    elif strategy == "C":
        prompt = strategy_c_first_pass(segments_text)
    elif strategy == "D":
        prompt = strategy_d_prompt(segments_text, prev_type, conv_id)
    elif strategy == "E":
        prompt = strategy_e_prompt(segments_text, prev_type, conv_id, video_title)
    else:
        raise ValueError(f"Unknown strategy: {strategy}")

    response = _call_ollama(prompt)
    if not response:
        # Fallback to all commentary
        return [
            SegmentAnalysis("commentary", 0, False, 0.5, "fallback")
            for _ in window
        ]

    # Parse response
    try:
        # Try to extract JSON
        json_str = None
        start = response.find("[")
        if start != -1:
            bracket_count = 0
            for i, char in enumerate(response[start:], start):
                if char == "[":
                    bracket_count += 1
                elif char == "]":
                    bracket_count -= 1
                    if bracket_count == 0:
                        json_str = response[start : i + 1]
                        break

        if json_str:
            analyses = json.loads(json_str)
            results: List[SegmentAnalysis] = []
            current_conv_id = conv_id

            for item in analyses:
                seg_type = item.get("type", "commentary")
                # Normalize segment type
                if seg_type not in ["approach", "commentary", "transition"]:
                    seg_type = "commentary"
                is_new = bool(item.get("new_conversation", False))
                raw_conf = item.get("confidence")
                confidence = float(raw_conf) if raw_conf is not None else 0.5

                if is_new and seg_type == "approach":
                    current_conv_id += 1

                results.append(
                    SegmentAnalysis(
                        segment_type=seg_type,
                        conversation_id=current_conv_id if seg_type == "approach" else 0,
                        is_new_conversation=is_new,
                        confidence=confidence,
                        reasoning=f"strategy_{strategy}",
                    )
                )

            return results
    except (json.JSONDecodeError, KeyError, ValueError) as e:
        print(f"[LLM_test] Parse error: {e}")

    # Fallback
    return [
        SegmentAnalysis("commentary", 0, False, 0.5, "parse_fallback")
        for _ in window
    ]


def process_file(
    input_path: Path,
    output_path: Path,
    strategy: str,
    video_title: str = ""
) -> Dict:
    """Process a single file with the specified strategy."""

    with input_path.open("r", encoding="utf-8") as f:
        data = json.load(f)

    segments = data.get("segments", [])
    print(f"[LLM_test] Processing {input_path.name} ({len(segments)} segments) with strategy {strategy}")

    # For strategy A, detect video type first
    video_type = "unknown"
    if strategy == "A":
        video_type = detect_video_type_with_llm(segments, video_title)
        print(f"[LLM_test] Detected video type: {video_type}")

    # Process windows
    total = len(segments)
    current_conv_id = 0
    prev_type = "unknown"
    idx = 0

    while idx < total:
        analyses = analyze_window(
            segments, idx, current_conv_id, prev_type, strategy, video_title, video_type
        )

        non_overlap_count = WINDOW_SIZE - WINDOW_OVERLAP if idx > 0 else WINDOW_SIZE
        for i, analysis in enumerate(analyses[:non_overlap_count]):
            seg_idx = idx + i
            if seg_idx >= total:
                break

            segments[seg_idx]["conversation_id"] = analysis.conversation_id
            segments[seg_idx]["segment_type"] = analysis.segment_type
            segments[seg_idx]["boundary_detection"] = {
                "is_new_conversation": analysis.is_new_conversation,
                "confidence": analysis.confidence,
                "method": analysis.reasoning,
            }

            if analysis.conversation_id > current_conv_id:
                current_conv_id = analysis.conversation_id
            prev_type = analysis.segment_type

        idx += WINDOW_SIZE - WINDOW_OVERLAP
        if idx >= total:
            break

        if (idx % 50) == 0:
            print(f"[LLM_test] Processed {idx}/{total} segments...")

    data["segments"] = segments

    # Summary
    conversation_ids = set()
    type_counts: Dict[str, int] = {}
    for seg in segments:
        conv_id = int(seg.get("conversation_id", 0) or 0)
        if conv_id > 0:
            conversation_ids.add(conv_id)
        seg_type = str(seg.get("segment_type", "unknown"))
        type_counts[seg_type] = type_counts.get(seg_type, 0) + 1

    data["conversation_summary"] = {
        "total_conversations": len(conversation_ids),
        "segment_type_counts": type_counts,
    }

    output_path.parent.mkdir(parents=True, exist_ok=True)
    with output_path.open("w", encoding="utf-8") as f:
        json.dump(data, f, indent=2)

    print(f"[LLM_test] Found {len(conversation_ids)} conversations")
    print(f"[LLM_test] Segment types: {type_counts}")

    return data


# Map input filenames to video titles
VIDEO_TITLES = {
    "texting-mistakes.json": "3 LOW-VALUE Texting Mistakes You're Probably Making",
    "introverts-charisma.json": "An Introverts Guide To Speaking With Charisma",
    "first-approach-advice.json": "Advice For Your First Cold Approach EVER",
    "brutal-session.json": "Brutal Daygame Session",
    "brutal-rejection.json": "Brutal Daygame Infield Rejection",
}


def main() -> None:
    parser = argparse.ArgumentParser(description="Test conversation classification strategies")
    parser.add_argument("--strategy", required=True, choices=["A", "B", "C", "D", "E"],
                        help="Which prompt strategy to use")
    parser.add_argument("--input", required=True, help="Input directory with test files")
    parser.add_argument("--output", required=True, help="Output directory for results")
    args = parser.parse_args()

    input_path = Path(args.input)
    output_path = Path(args.output)
    output_path.mkdir(parents=True, exist_ok=True)

    # Check Ollama
    try:
        response = requests.get(f"{OLLAMA_BASE_URL}/api/tags", timeout=5)
        if not response.ok:
            print(f"[LLM_test] Warning: Ollama not available")
            return
    except requests.exceptions.RequestException:
        print(f"[LLM_test] Cannot connect to Ollama at {OLLAMA_BASE_URL}")
        return

    # Process each input file
    for input_file in sorted(input_path.glob("*.json")):
        video_title = VIDEO_TITLES.get(input_file.name, input_file.stem)
        output_file = output_path / f"{input_file.stem}.conversations.json"

        print(f"\n{'='*60}")
        print(f"Processing: {input_file.name}")
        print(f"Video title: {video_title}")
        print(f"Strategy: {args.strategy}")
        print(f"{'='*60}")

        process_file(input_file, output_file, args.strategy, video_title)

    print("\n[LLM_test] Done!")


if __name__ == "__main__":
    main()
